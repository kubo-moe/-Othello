#include <iostream>
int shiro(int &a, int b, int tate, int yoko, int (&s)[8][8], int &flag, int &num);

int kuro(int &a, int b, int tate, int yoko, int (&s)[8][8], int &flag, int &num)
{
    int i = 0; //ループカウンタ
    int j = 0; //ループカウンタ
    int k = 0; //ループカウンタ

    std::cout << "・相手の番です。相手は黒石です(○)" << std::endl; //テキストを表示
    std::cout << "・スキップする場合は0を入力してください。" << std::endl;
    std::cout << "・終了するときは9を入力してください。" << std::endl;
    do
    {
        std::cout << "・置きたい行(縦)を入力してください："; //テキストを表示
        std::cin >> a;                                       //数値の入力
        if (a == 0 || a == 9)
        {
            break;
        }
        if (a > 8 || a < 1)
        {                                                              //指定外の数値が入力されたら
            std::cout << "・1~8の数字で入力して下さい。" << std::endl; //テキストを表示
        }
    } while (a > 8 || a < 1); //指定範囲外の数値が入力されたらループ

    if (a != 0 && a != 9)
    {
        do
        {
            std::cout << "・置きたい列(横)を入力してください："; //テキストを表示
            std::cin >> b;                                       //数値の入力
            if (b > 8 || b < 1)
            {                                                              //指定外の数値が入力されたら
                std::cout << "・1~8の数字で入力して下さい。" << std::endl; //テキストを表示
            }
        } while (b > 8 || b < 1); //指定範囲外の数値が入力されたらループ
    }

    if (a != 0)
    {
        //配列の要素に白黒の判別をつける
        if (s[a - 1][b - 1] == 0)
        {                        //入力値のマスが空白なら
            s[a - 1][b - 1] = 2; //黒石(判定)を置く
        }
        //縦横の相手の石の判定
        //下の処理
        if (s[a][b - 1] == 1)
        { //入力値の下マスが白なら
            for (i = 1; i < 8; i++)
            { //ループカウンタ
                if (s[a][b - 1] == 1 && s[a + 1][b - 1] == 0)
                {          //下が白且つその下が空白の時
                    break; //ループを抜ける
                }
                if (s[a][b - 1] == 1 && s[a + 1][b - 1] == 2)
                {                    //下が白且つその下が黒なら
                    s[a][b - 1] = 2; //黒石(判定)を置く
                    break;           //ループを抜ける
                }

                if (s[a + i][b - 1] == 1 && s[a + i + 1][b - 1] == 0)
                { //iマス下が白且つその下が空白なら
                    break;
                }
                if (s[a + i][b - 1] == 1 && s[a + i + 1][b - 1] == 2)
                {                    //iマス下が白且つその下が黒なら
                    s[a][b - 1] = 2; //黒石(判定)を置く
                    for (k = 1; k <= i; k++)
                    {                        //ループを抜ける
                        s[a + k][b - 1] = 2; //黒石(判定)を置く
                    }
                    break; //ループを抜ける
                }
            }
        }
        //上の処理
        if (s[a - 2][b - 1] == 1)
        { //入力値の上が白なら
            for (i = 3; i < 8; i++)
            { //ループカウンタ
                if (s[a - 2][b - 1] == 1 && s[a - 3][b - 1] == 0)
                {          //上が白且つその上が空白なら
                    break; //ループを抜ける
                }
                if (s[a - 2][b - 1] == 1 && s[a - 3][b - 1] == 2)
                {                        //上が白且つその上が黒なら
                    s[a - 2][b - 1] = 2; //黒石(判定)を置く
                    break;               //ループを抜ける
                }
                if (s[a - i][b - 1] == 1 && s[a - i - 1][b - 1] == 0)
                { //さらにその上のマスが空白なら
                    break;
                }
                if (s[a - i][b - 1] == 1 && s[a - i - 1][b - 1] == 2)
                {                        //さらにその上のマスが白なら
                    s[a - 2][b - 1] = 2; //黒石(判定)を置く
                    for (k = 3; k <= i; k++)
                    {                        //ループカウンタ
                        s[a - k][b - 1] = 2; //黒石(判定)を置く
                    }
                    break; //ループを抜ける
                }
            }
        }
        //右隣の処理
        if (s[a - 1][b] == 1)
        { //入力値の右隣が白なら
            for (i = 1; i < 8; i++)
            { //ループカウンタ
                if (s[a - 1][b] == 1 && s[a - 1][b + 1] == 0)
                {          //右が白且つその右が空白なら
                    break; //ループを抜ける
                }
                if (s[a - 1][b] == 1 && s[a - 1][b + 1] == 2)
                {                    //右が白且つその右が黒なら
                    s[a - 1][b] = 2; //黒石(判定)を置く
                    break;           //ループを抜ける
                }

                if (s[a - 1][b + i] == 1 && s[a - 1][b + i + 1] == 0)
                { //iマス右が白且つその右が空白なら
                    break;
                }
                if (s[a - 1][b + i] == 1 && s[a - 1][b + i + 1] == 2)
                {                    //iマス右が白且つその右が黒なら
                    s[a - 1][b] = 2; //黒石(判定)を置く
                    for (k = 1; k <= i; k++)
                    {                        //ループカウンタ
                        s[a - 1][b + k] = 2; //黒石(判定)を置く
                    }
                    break; //ループを抜ける
                }
            }
        }
        //左隣の処理
        if (s[a - 1][b - 2] == 1)
        { //入力値の左隣が白なら
            for (i = 3; i < 8; i++)
            { //ループカウンタ
                if (s[a - 1][b - 2] == 1 && s[a - 1][b - 3] == 0)
                {          //左が白且つその左が空白なら
                    break; //ループを抜ける
                }
                if (s[a - 1][b - 2] == 1 && s[a - 1][b - 3] == 2)
                {                        //左が白且つその左が黒なら
                    s[a - 1][b - 2] = 2; //黒石(判定)を置く
                    break;               //ループを抜ける
                }

                if (s[a - 1][b - i] == 1 && s[a - 1][b - i - 1] == 0)
                { //iマス左が白且つその左が空白なら
                    break;
                }
                if (s[a - 1][b - i] == 1 && s[a - 1][b - i - 1] == 2)
                {                        //iマス左が白且つその左が黒なら
                    s[a - 1][b - 2] = 2; //黒石(判定)を置く
                    for (k = 3; k <= i; k++)
                    {                        //ループカウンタ
                        s[a - 1][b - k] = 2; //黒石(判定)を置く
                    }
                    break; //ループを抜ける
                }
            }
        }
        //斜めの相手の石の判定
        //左下の判定
        if (s[a][b - 2] == 1)
        {          //入力値の斜め左下が白なら
            j = 1; //行用のカウンタ
            for (i = 3; i < 8; i++)
            { //ループカウンタ
                if (s[a][b - 2] == 1 && s[a + 1][b - 3] == 0)
                { //左下が白且つその左下が空白なら
                    break;
                }
                if (s[a][b - 2] == 1 && s[a + 1][b - 3] == 2)
                {                    //左下が白且つその左下が黒なら
                    s[a][b - 2] = 2; //黒石(判定)を置く
                    break;           //ループを抜ける
                }

                if (s[a + j][b - i] == 1 && s[a + j + 1][b - i - 1] == 0)
                { //iマス左下が白且つ更に斜め左下が空白なら
                    break;
                }
                if (s[a + j][b - i] == 1 && s[a + j + 1][b - i - 1] == 2)
                {                    //iマス左下が白且つ更に斜め左下が黒なら
                    j = 1;           //行用のカウンタ
                    s[a][b - 2] = 2; //黒石(判定)を置く
                    for (k = 3; k <= i; k++)
                    {                        //ループカウンタ
                        s[a + j][b - k] = 2; //黒石(判定)を置く
                        j++;                 //jをインクリメント
                    }
                    break; //ループを抜ける
                }
                j++; //jをインクリメント
            }
        }
        //右上の判定
        if (s[a - 2][b] == 1)
        {          //入力値の斜め右上が白なら
            j = 1; //列用のカウンタ
            for (i = 3; i < 8; i++)
            { //ループカウンタ
                if (s[a - 2][b] == 1 && s[a - 3][b + 1] == 0)
                { //右上が白且つその右上が空白なら
                    break;
                }
                if (s[a - 2][b] == 1 && s[a - 3][b + 1] == 2)
                {                    //右上が白且つその右上が黒なら
                    s[a - 2][b] = 2; //黒石(判定)を置く
                    break;           //ループを抜ける
                }

                if (s[a - i][b + j] == 1 && s[a - i - 1][b + j + 1] == 0)
                { //iマス右上が白且つその右上が空白なら
                    break;
                }
                if (s[a - i][b + j] == 1 && s[a - i - 1][b + j + 1] == 2)
                {                    //iマス右上が白且つその右上が黒なら
                    j = 1;           //列用のカウンタ
                    s[a - 2][b] = 2; //黒石(判定)を置く
                    for (k = 3; k <= i; k++)
                    {                        //ループカウンタ
                        s[a - k][b + j] = 2; //黒石(判定)を置く
                        j++;                 //jをインクリメント
                    }
                    break; //ループを抜ける
                }
                j++; //jをインクリメント
            }
        }
        //左上の判定
        if (s[a - 2][b - 2] == 1)
        {          //入力値の斜め左上が白なら
            j = 3; //列用のカウンタ
            for (i = 3; i < 8; i++)
            { //ループカウンタ
                if (s[a - 2][b - 2] == 1 && s[a - 3][b - 3] == 0)
                { //左上が白且つその左上が空白なら
                    break;
                }
                if (s[a - 2][b - 2] == 1 && s[a - 3][b - 3] == 2)
                {                        //左上が白且つその左上が黒なら
                    s[a - 2][b - 2] = 2; //黒石(判定)を置く
                    break;               //ループを抜ける
                }

                if (s[a - i][b - j] == 1 && s[a - i - 1][b - j - 1] == 0)
                { //iマス左上が白且つその左上が空白なら
                    break;
                }
                if (s[a - i][b - j] == 1 && s[a - i - 1][b - j - 1] == 2)
                {                        //iマス左上が白且つその左上が黒なら
                    j = 3;               //列用のカウンタ
                    s[a - 2][b - 2] = 2; //黒石(判定)を置く
                    for (k = 3; k <= i; k++)
                    {                        //ループカウンタ
                        s[a - k][b - j] = 2; //黒石(判定)を置く
                        j++;                 //jをインクリメント
                    }
                    break; //ループを抜ける
                }
                j++; //jをインクリメント
            }
        }

        //右下の判定
        if (s[a][b] == 1)
        {          //入力値の斜め右下が白なら
            j = 1; //列用のカウンタ
            for (i = 1; i < 8; i++)
            { //ループカウンタ
                if (s[a][b] == 1 && s[a + 1][b + 1] == 0)
                { //右下が白且つその右上が空白なら
                    break;
                }
                if (s[a][b] == 1 && s[a + 1][b + 1] == 2)
                {                //右下が白且つその右上が黒なら
                    s[a][b] = 2; //黒石(判定)を置く
                    break;       //ループを抜ける
                }

                if (s[a + i][b + j] == 1 && s[a + i + 1][b + j + 1] == 0)
                {          //iマス右下が白且つその右上が空白なら
                    break; //ループを抜ける
                }
                if (s[a + i][b + j] == 1 && s[a + i + 1][b + j + 1] == 2)
                {                //iマス右下が白且つその右上が黒なら
                    j = 1;       //列用のカウンタ
                    s[a][b] = 2; //黒石(判定)を置く
                    for (k = 1; k <= i; k++)
                    {                        //ループカウンタ
                        s[a + k][b + j] = 2; //黒石(判定)を置く
                        j++;                 //jをインクリメント
                    }
                    break; //ループを抜ける
                }
                j++; //jをインクリメント
            }
        }

        //盤面表示
        std::cout << std::endl;
        std::cout << "  1 2 3 4 5 6 7 8" << std::endl; //列を表示
        for (i = 0; i < tate; i++)
        {                       //縦に8つ表示するまでループ
            std::cout << i + 1; //行を表示
            for (j = 0; j < yoko; j++)
            { //横に8つ表示するまでループ
                if (s[i][j] == 1)
                {                      //配列内に1があれば
                    std::cout << " ●"; //黒石を表示
                }
                else if (s[i][j] == 2)
                {                      //配列内に2があれば
                    std::cout << " ○"; //白石を表示
                }
                else
                {                      //それ以外は
                    std::cout << "  "; //空白を表示
                }
            }
            std::cout << std::endl; //4つ表示したら改行
        }
        std::cout << std::endl; //インデント用改行
        flag++;
        num++;
    }
    if (a == 9)
    {
        return s[8][8], flag, num, a;
    }
    shiro(a, b, tate, yoko, s, flag, num); //相手の黒石を反転する
    return s[8][8], flag, num, a;
}